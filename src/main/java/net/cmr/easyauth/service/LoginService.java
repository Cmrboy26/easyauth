package net.cmr.easyauth.service;

import java.nio.charset.Charset;
import java.util.Base64;
import java.util.Date;
import java.util.concurrent.CompletableFuture;

import javax.crypto.SecretKey;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.http.ResponseEntity;
import org.springframework.lang.Nullable;
import org.springframework.scheduling.annotation.Async;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;
import net.cmr.easyauth.AuthMessages;
import net.cmr.easyauth.config.SecurityConfig;
import net.cmr.easyauth.controller.CookieUtils;
import net.cmr.easyauth.entity.ElevateRequest;
import net.cmr.easyauth.entity.Login;
import net.cmr.easyauth.entity.LoginRequest;
import net.cmr.easyauth.entity.RegisterRequest;
import net.cmr.easyauth.entity.SessionInfo;
import net.cmr.easyauth.repository.LoginRepository;

@Service
public class LoginService {
    
    //private static SecretKey jwtsSecretKey = Keys.secretKeyFor(SignatureAlgorithm.HS256);
    @Autowired private LoginRepository loginRepository;
    
    @Value("${net.cmr.easyauth.jwtExpirationSeconds}")    
    private int jwtExpirationSeconds;
    @Value("${net.cmr.easyauth.jwtSecretKey}")    
    private String secretKeyConfiguration;
    private static SecretKey secretKey;

    public static final Logger logger = LoggerFactory.getLogger(LoginService.class);
    
    @Autowired
    public void setSecret() {
        if (secretKeyConfiguration.equals("AUTOGENERATE")) {
            logger.info("Autogenerating JWT secret key...");
            secretKey = Keys.secretKeyFor(SignatureAlgorithm.HS256);
            String base64String = Base64.getEncoder().encodeToString(secretKey.getEncoded());
            logger.info("AUTOGENERATED KEY: " + base64String);
        } else {
            byte[] keyBytes = Base64.getDecoder().decode(secretKeyConfiguration);
            secretKey = Keys.hmacShaKeyFor(keyBytes);
            logger.info("Successfully loaded JWT secret key.");
        }
    }

    @Async
    public CompletableFuture<ResponseEntity<SessionInfo>> attemptLogin(HttpServletResponse response, LoginRequest request) {

        // Verify request contents are valid

        // Get login object, return false success with nothing if not present
        
        Login login = loginRepository.findByUsernameOrEmail(request.getPrimaryCredential(), request.getPrimaryCredential());
        if (login == null) {
            return CompletableFuture.completedFuture(ResponseEntity.status(401).body(new SessionInfo()));
        }

        if (!validPassword(login, request.getPlaintextPassword())) {
            return CompletableFuture.completedFuture(ResponseEntity.status(401).body(new SessionInfo()));
        }

        Date expirationDate = new Date(System.currentTimeMillis() + 1000 * jwtExpirationSeconds);
        String jwt = Jwts.builder().setExpiration(expirationDate).setSubject(login.getCombinedPrimaryCredential()).signWith(secretKey).compact();
        Cookie cookie = CookieUtils.createJwtCookie(jwt, jwtExpirationSeconds);
        response.addCookie(cookie);

        return CompletableFuture.completedFuture(ResponseEntity.ok().header("Authorization", "Bearer "+jwt).body(new SessionInfo(jwt, jwtExpirationSeconds)));
    }

    @Async
    public CompletableFuture<ResponseEntity<String>> registerLogin(RegisterRequest request) {
        // Check if username or email has ":" in it. if so, don't allow
        if (request.getEmail() == null || request.getUsername() == null || request.getEmail().contains(":") || request.getUsername().contains(":")) {
            return CompletableFuture.completedFuture(ResponseEntity.badRequest().body(AuthMessages.INVALID_CREDENTIAL));
        }

        Login login = new Login(request);
        if (loginRepository.findByUsernameOrEmail(login.getUsername(), login.getEmail()) != null) {
            // Already exists in database
            return CompletableFuture.completedFuture(ResponseEntity.badRequest().body(AuthMessages.ACCOUNT_ALREADY_EXISTS));
        }
        loginRepository.save(login);
        return CompletableFuture.completedFuture(ResponseEntity.ok().build());
    }

    private boolean validPassword(Login login, String plaintextPassword) {
        return BCrypt.checkpw(plaintextPassword, login.getPasswordHash());
    }

    @Async
    public CompletableFuture<ResponseEntity<String>> verifyLogin(String jwt) {
        return CompletableFuture.completedFuture(ResponseEntity.ok(Boolean.toString(isActiveJwsToken(jwt, loginRepository))));
    }

    @Async
    public CompletableFuture<ResponseEntity<String>> verifyLogin(SessionInfo sessionInfo) {
        return verifyLogin(sessionInfo.getJwt());
    }

    @Async
    public CompletableFuture<ResponseEntity<String>> elevateRole(ElevateRequest elevateRequest) {
        if (!SecurityConfig.isValidRole(elevateRequest.getRole())) {
            return CompletableFuture.completedFuture(ResponseEntity.badRequest().body(AuthMessages.INVALID_ROLE));
        }
        Login login = loginRepository.findByUsernameOrEmail(elevateRequest.getPrimaryCredential(), elevateRequest.getPrimaryCredential());
        if (login == null) {
            return CompletableFuture.completedFuture(ResponseEntity.badRequest().body(AuthMessages.MISSING_USER));
        }
        login.setRole(elevateRequest.getRole());
        loginRepository.save(login);
        return CompletableFuture.completedFuture(ResponseEntity.ok().body(Boolean.toString(true)));
    }

    public static boolean isActiveJwsToken(String jwt, @Nullable LoginRepository repository) {
        try {
            String combinedCredential = getCombinedCredentialFromJwt(jwt);
            if (repository != null) {
                String username = Login.getUsernameFromCombinedCredential(combinedCredential);
                String email = Login.getEmailFromCombinedCredential(combinedCredential);

                Login login = repository.findByUsernameOrEmail(username, email);
                boolean valid = login != null;
                return valid;
            }
            return true;
        } catch (JwtException e) {
            return false;
        }
    }

    /**
     * Extracts the JWT from the specified content header, which may take the format "Bearer {{jwttoken}}"
     * @param headerContent header content from the key "Authorization"
     * @return JWT token
     */
    public static String extractJwt(String headerContent) throws IllegalArgumentException {
        try {
            return headerContent.split(" ")[1];
        } catch (Exception e) {
            throw new IllegalArgumentException(AuthMessages.INVALID_JWT_FORMAT);
        }
    }

    public static Date getExpirationFromJwt(String jwt) throws JwtException {
        return parseJwtClaims(jwt).getBody().getExpiration();
    }

    /**
     * Extracts the subject (combined credential) from a JWT token
     * @param jwt the JWT token
     * @return the subject from the JWT claims
     */
    public static String getCombinedCredentialFromJwt(String jwt) throws JwtException {
        return parseJwtClaims(jwt).getBody().getSubject();
    }
    
    /**
     * Parses the given JWT string and returns its claims.
     *
     * @param jwt the JSON Web Token string to be parsed
     * @return the parsed JWT claims
     * @throws JwtException if the JWT is invalid or cannot be parsed (see JwtParser.praseClaimsJws(String))
     */
    public static Jws<Claims> parseJwtClaims(String jwt) throws JwtException {
        return Jwts.parserBuilder().setSigningKey(secretKey).build().parseClaimsJws(jwt);
    }

}
